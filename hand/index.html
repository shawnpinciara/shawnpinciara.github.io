<!doctype html>
<html lang="it">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Hand CCs</title>
	<!-- p5 from CDN -->
	<script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
	<!-- local loader for Handsfree (loads the real build from unpkg) -->
	<script src="handsfree.js"></script>
	<style>
		html,body{height:100%;margin:0}
		#sketch-container{position:fixed;top:0;left:0;right:0;bottom:0}
		/* small debug window in bottom-left */
		#debugWrap{position:fixed;left:12px;bottom:12px;width:260px;height:195px;z-index:9999;border:2px solid rgba(0,0,0,0.5);background:rgba(0,0,0,0.1);overflow:hidden;border-radius:6px}
			#debugToolbar{position:absolute;left:6px;right:6px;top:6px;display:flex;justify-content:space-between;align-items:center;gap:8px;z-index:10001;pointer-events:auto}
		#distanceDisplay{font-size:13px;padding:4px 6px;background:rgba(0,0,0,0.35);border-radius:4px}
			#topControls{position:fixed;top:12px;right:12px;display:flex;gap:10px;align-items:center;z-index:10003;pointer-events:auto;background:rgba(255,255,255,0.9);padding:6px 10px;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
			#topControls > div, #topControls > select, #topControls > button, #topControls > span{color:#000}
		#resizeHandle{position:absolute;right:4px;bottom:4px;width:18px;height:18px;cursor:nwse-resize;z-index:10002;background:linear-gradient(135deg,rgba(255,255,255,0.25) 0%,rgba(255,255,255,0.05) 100%);border-radius:3px}
		#thresholdControl input[type="range"]{vertical-align:middle}



		/* Hands display styling */
		#handsDisplay{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);display:flex;gap:48px;align-items:center;z-index:9998;pointer-events:none}
		.handSvg{width:180px;height:260px;fill:#ddd;transition:fill 120ms linear;filter:drop-shadow(0 6px 14px rgba(0,0,0,0.15))}
		/* Left hand labels that move with the hand */
		#rightHandLabels{transition:transform 120ms linear, opacity 200ms ease;z-index:9999}
		#rightHandLabels > div{line-height:1.4}
		/* Right hand labels that move with the hand */
		#leftHandLabels{transition:transform 120ms linear, opacity 200ms ease;z-index:9999}
		#leftHandLabels > div{line-height:1.4}
		/* CC toggle buttons */
		.cc-toggle{transition:background 200ms ease, color 200ms ease}
		.cc-toggle:hover{opacity:0.8}
			/* left/right handled by SVG content; no CSS flip here */
		/* make Handsfree video/canvas fill the wrapper */
			#debugWrap .handsfree-video,
			#debugWrap .handsfree-canvas-hands{width:100% !important;height:100% !important;object-fit:cover;display:block;transform:scaleX(-1);transform-origin:center center}
		/* hide other debugging canvases (we only want the hands view) */
		#debugWrap .handsfree-canvas{display:none}
		#debugWrap .handsfree-canvas-hands{display:block}
	</style>
</head>
<body>
	<!-- Welcome Popup -->
	<div id="welcomePopup" style="position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:99999;pointer-events:auto;">
		<div style="background:rgba(255,255,255,0.95);padding:48px;border-radius:12px;max-width:600px;text-align:center;box-shadow:0 12px 40px rgba(0,0,0,0.3);cursor:pointer;">
			<h1 style="margin:0 0 12px 0;font-size:28px;color:#333;">Hand position → MIDI CCs</h1>
			<h2 style="margin:0 0 20px 0;font-size:18px;color:#666;font-weight:normal;">Have fun with yo hands!</h2>
			<p style="margin:0 0 16px 0;font-size:14px;color:#555;line-height:1.6;">Convert the position, rotation, distance of both of your hands (and some gestures such as pinching the index finger with the thumb) to midi cc to map in your daw!</p>
			<p style="margin:0 0 16px 0;font-size:14px;color:#d9534f;font-weight:bold;">‼ Enable both the camera and midi ‼</p>
			<p style="margin:0 0 20px 0;font-size:12px;color:#999;font-style:italic;">This was entirely vibecoded, it would take me weeks to do this alone, even if i know all libraries involved!</p>
			<p style="margin:0;font-size:12px;color:#999;">Click anywhere to exit the popup</p>
		</div>
	</div>
	<script>
		// Close popup on any click
		document.getElementById('welcomePopup').addEventListener('click', function() {
			this.style.display = 'none';
		});
	</script>

	<div id="sketch-container"></div>
			<!-- Hands display: two SVGs, left and right -->
		<div id="handsDisplay" aria-hidden="true">
			<!-- Left hand maps to index 0 (CC35-37,41,43-46), Right hand maps to index 1 (CC38-40,42,47-50) -->
				<!-- Right: reflected on X axis -->
				<svg id="handRight" viewBox="0 0 600 600" class="handSvg" aria-label="Right hand">
					<path d="m200.5,532.5l240.5,0.5c-37.49809,0.5 8.5,-119.43386 8.5,-187.5c0,-68.06614 -54,-57 -64,-41c0,-31 -1,7 -1,-102c0,-109 -209,-123 -210,13c-1,136 24,169 26,317z" id="svg_2_left" />
					<!-- Pinch indicator circle (bottom-right of hand) -->
					<circle id="pinchCircle" cx="480" cy="480" r="35" fill="#ccc" opacity="0.8" />
				</svg>
		<!-- Labels for right hand (positioned top-left of hand) -->
		<div id="rightHandLabels" style="position:absolute;left:50%;top:50%;transform:translate(-220px, -150px);pointer-events:none;background:rgba(255,255,255,0.85);padding:6px 10px;border-radius:6px;font-family:monospace;font-size:10px;color:#000;box-shadow:0 2px 8px rgba(0,0,0,0.1);">
			<div id="rightLabel_x">X (CC35): —</div>
			<div id="rightLabel_y">Y (CC36): —</div>
			<div id="rightLabel_dist">Dist (CC37): —</div>
			<div id="rightLabel_rot">Rot (CC41): —</div>
			<div id="rightLabel_pinch">Pinch (CC43): —</div>
			<div id="rightLabel_pinch_x">PX (CC44): —</div>
			<div id="rightLabel_pinch_y">PY (CC45): —</div>
			<div id="rightLabel_pinch_rot">PR (CC46): —</div>
		</div>
				<!-- Left: original (no reflection) -->
				<svg id="handLeft" viewBox="0 0 600 600" class="handSvg" aria-label="Left hand">
					<g transform="translate(300 0) scale(-1 1) translate(-300 0)">
						<path d="m200.5,532.5l240.5,0.5c-37.49809,0.5 8.5,-119.43386 8.5,-187.5c0,-68.06614 -54,-57 -64,-41c0,-31 -1,7 -1,-102c0,-109 -209,-123 -210,13c-1,136 24,169 26,317z" id="svg_2_right" />
						<!-- Pinch indicator circle (bottom-right of hand, mirrored) -->
						<circle id="pinchCircleLeft" cx="480" cy="480" r="35" fill="#ccc" opacity="0.8" />
					</g>
				</svg>
		<!-- Labels for left hand (positioned top-left of hand) -->
		<div id="leftHandLabels" style="position:absolute;left:50%;top:50%;transform:translate(70px, -150px);pointer-events:none;background:rgba(255,255,255,0.85);padding:6px 10px;border-radius:6px;font-family:monospace;font-size:10px;color:#000;box-shadow:0 2px 8px rgba(0,0,0,0.1);">
			<div id="leftLabel_x">X (CC38): —</div>
			<div id="leftLabel_y">Y (CC39): —</div>
			<div id="leftLabel_dist">Dist (CC40): —</div>
			<div id="leftLabel_rot">Rot (CC42): —</div>
			<div id="leftLabel_pinch">Pinch (CC47): —</div>
			<div id="leftLabel_pinch_x">PX (CC48): —</div>
			<div id="leftLabel_pinch_y">PY (CC49): —</div>
			<div id="leftLabel_pinch_rot">PR (CC50): —</div>
		</div>
			</div>
	<!-- Debug wrapper for Handsfree (webcam + hands canvas) -->
			<div id="debugWrap" aria-hidden="true">
				<div id="debugToolbar"></div>
				<div id="resizeHandle" title="Ridimensiona" aria-hidden="true"></div>
			</div>
			<!-- top-right controls (moved out of debug preview) -->
			<div id="topControls" aria-hidden="false">
				<div id="distanceDisplay" style="color:#000;font-family:monospace;">—</div>
				<div id="midiControl" style="display:flex;align-items:center;gap:8px;color:#000;font-family:monospace;">
					<button id="midiEnable" style="background:rgba(0,0,0,0.06);border:0;color:#000;padding:4px 6px;border-radius:4px;cursor:pointer">Enable MIDI</button>
					<select id="midiOutSelect" style="background:rgba(255,255,255,0.85);color:#000;border:0;padding:4px 6px;border-radius:4px;">
						<option value="">(no output)</option>
					</select>
				</div>
				<div id="thresholdControl" style="display:flex;align-items:center;gap:6px;">
					<label for="thresholdSlider" style="color:#000;font-size:12px;">Precision:</label>
					<input id="thresholdSlider" type="range" min="0" max="1" step="0.01" value="0.1" style="width:110px">
					<span id="thresholdValue" style="color:#000;font-family:monospace;font-size:12px;">0.10</span>
				</div>
			</div>

	<!-- Bottom CC enable/disable buttons -->
	<div id="ccButtons" style="position:fixed;bottom:12px;left:50%;transform:translateX(-50%);display:flex;gap:24px;z-index:10003;background:rgba(255,255,255,0.9);padding:12px;border-radius:6px;box-shadow:0 6px 18px rgba(0,0,0,0.08);align-items:flex-start;justify-content:center;flex-wrap:wrap;">
		
		<!-- Title above all buttons -->
		<span style="color:#666;font-size:11px;font-weight:bold;width:100%;text-align:center;margin-bottom:4px;">Enable/Disable CCs:</span>
		
		<!-- LEFT HAND GROUP (CC35-37, CC41, CC43-46) -->
		<div style="display:flex;flex-direction:column;gap:6px;align-items:center;">
			<span style="color:#666;font-size:10px;font-weight:bold;margin-bottom:2px;">Left Hand</span>
			
			<!-- Row 1: CC35-37, CC41 -->
			<div style="display:flex;gap:6px;justify-content:center;">
				<button class="cc-toggle" data-cc-index="0" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC35</button>
				<button class="cc-toggle" data-cc-index="1" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC36</button>
				<button class="cc-toggle" data-cc-index="2" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC37</button>
				<button class="cc-toggle" data-cc-index="6" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC41</button>
			</div>
			
			<!-- Row 2: CC43-46 -->
			<div style="display:flex;gap:6px;justify-content:center;">
				<button class="cc-toggle" data-cc-index="8" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC43</button>
				<button class="cc-toggle" data-cc-index="9" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC44</button>
				<button class="cc-toggle" data-cc-index="10" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC45</button>
				<button class="cc-toggle" data-cc-index="11" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC46</button>
			</div>
		</div>
		
		<!-- Divider line -->
		<div style="width:1px;height:60px;background:#ddd;"></div>
		
		<!-- RIGHT HAND GROUP (CC38-40, CC42, CC47-50) -->
		<div style="display:flex;flex-direction:column;gap:6px;align-items:center;">
			<span style="color:#666;font-size:10px;font-weight:bold;margin-bottom:2px;">Right Hand</span>
			
			<!-- Row 1: CC38-40, CC42 -->
			<div style="display:flex;gap:6px;justify-content:center;">
				<button class="cc-toggle" data-cc-index="3" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC38</button>
				<button class="cc-toggle" data-cc-index="4" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC39</button>
				<button class="cc-toggle" data-cc-index="5" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC40</button>
				<button class="cc-toggle" data-cc-index="7" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC42</button>
			</div>
			
			<!-- Row 2: CC47-50 -->
			<div style="display:flex;gap:6px;justify-content:center;">
				<button class="cc-toggle" data-cc-index="12" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC47</button>
				<button class="cc-toggle" data-cc-index="13" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC48</button>
				<button class="cc-toggle" data-cc-index="14" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC49</button>
				<button class="cc-toggle" data-cc-index="15" style="padding:6px 10px;border:2px solid #666;background:#666;color:#fff;border-radius:4px;cursor:pointer;font-family:monospace;font-size:11px;font-weight:bold;">CC50</button>
			</div>
		</div>
	</div>

	<script>
		// Console logs requested by user
		console.log('caricato p5js (script tag inserito)');

		// Shared state updated by Handsfree plugin
		let handScale = 0;
		// lastDistances holds per-hand numeric metrics (index order)
		let lastDistances = [];
		// detection confidence threshold (0..1). If a hand's reported confidence is below this,
		// we ignore its values. Default 0.7 as requested.
		let detectionThreshold = 0.7;
		// distance threshold: if the computed distance metric is less than this value,
		// we consider the hand too close/invalid for UI updates. Default 0.1
		let distanceThreshold = 0.1;

			// MIDI state
			let midiAccess = null;
			let midiOut = null; // selected MIDIOutput
			let midiEnabled = false;
		// CC numbers to use (remapped per user request)
		const CC_LEFT_X = 35;    // left hand X
		const CC_LEFT_Y = 36;    // left hand Y
		const CC_LEFT_DIST = 37; // left hand distance
		const CC_RIGHT_X = 38;   // right hand X
		const CC_RIGHT_Y = 39;   // right hand Y
		const CC_RIGHT_DIST = 40; // right hand distance
		const CC_LEFT_ROT = 41;   // left hand rotation
		const CC_RIGHT_ROT = 42;  // right hand rotation
		// Pinch-based CC (new)
		const CC_LEFT_PINCH = 43; // left hand pinch state (0-127)
		const CC_LEFT_PINCH_X = 44; // left hand X during pinch
		const CC_LEFT_PINCH_Y = 45; // left hand Y during pinch
		const CC_LEFT_PINCH_ROT = 46; // left hand rotation during pinch
		const CC_RIGHT_PINCH = 47; // right hand pinch state (0-127)
		const CC_RIGHT_PINCH_X = 48; // right hand X during pinch
		const CC_RIGHT_PINCH_Y = 49; // right hand Y during pinch
		const CC_RIGHT_PINCH_ROT = 50; // right hand rotation during pinch
		// throttle MIDI sends (ms)
		const midiThrottleMs = 40;
		let lastMidiSentAt = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]; // expanded for 16 CCs
		let lastMidiValue = [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null]; // same order
		// CC enable/disable state (all enabled by default)
		let ccEnabled = [true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true]; // indices: [cc35-50]
		// hand position tracking (0..1 normalized)
		let handPositions = [[0.5, 0.5], [0.5, 0.5]]; // [[x,y] right, [x,y] left]
		let handPositionsMM = [null, null]; // last-sent MIDI values (to detect change)
		// hand rotation tracking (in degrees, -180 to 180, 0 = vertical)
		let handRotations = [0, 0]; // [right, left]
		// pinch detection (thumb-index distance)
		let pinchActive = [false, false]; // [right, left]
		const pinchThreshold = 0.05; // distance threshold for pinch detection (normalized 0..1)

		function updateMidiStatusText(text){
				const el = document.getElementById('midiStatus');
				if (el) el.textContent = text;
			}

			function updateMidiLastText(){
				// update right-side per-CC display with new CC mapping
				const ccLabels = [
					{ id: 'cc35', label: 'Right Hand X', cc: 35 },
					{ id: 'cc36', label: 'Right Hand Y', cc: 36 },
					{ id: 'cc37', label: 'Right Hand Dist', cc: 37 },
					{ id: 'cc38', label: 'Left Hand X', cc: 38 },
					{ id: 'cc39', label: 'Left Hand Y', cc: 39 },
					{ id: 'cc40', label: 'Left Hand Dist', cc: 40 },
					{ id: 'cc41', label: 'Right Hand Rot', cc: 41 },
					{ id: 'cc42', label: 'Left Hand Rot', cc: 42 }
				];
				ccLabels.forEach((info, idx) => {
					const el = document.getElementById(info.id);
					if (el) {
						const val = lastMidiValue[idx] === null ? '—' : lastMidiValue[idx];
						el.textContent = `${info.label} (CC ${info.cc}): ${val}`;
						// update visual state (darker if disabled)
						el.style.opacity = ccEnabled[idx] ? '1' : '0.35';
						el.style.cursor = 'pointer';
					}
				});
			}

		// toggle CC enabled state on click
		function toggleCCEnabled(ccIndex){
			ccEnabled[ccIndex] = !ccEnabled[ccIndex];
			updateMidiLastText();
			// Update button visual state
			const btn = document.querySelector(`.cc-toggle[data-cc-index="${ccIndex}"]`);
			if (btn) {
				if (ccEnabled[ccIndex]) {
					btn.style.background = '#666';
					btn.style.color = '#fff';
				} else {
					btn.style.background = 'transparent';
					btn.style.color = '#999';
				}
			}
		}			async function enableMidi(){
				try{
					midiAccess = await navigator.requestMIDIAccess();
					const outs = Array.from(midiAccess.outputs.values());
					const select = document.getElementById('midiOutSelect');
					if (select) {
						// populate select with outputs
						select.innerHTML = '';
						if (outs.length === 0) {
							const opt = document.createElement('option'); opt.value = ''; opt.textContent = '(no output)'; select.appendChild(opt);
						} else {
							outs.forEach((o) => {
								const opt = document.createElement('option');
								opt.value = o.id;
								opt.textContent = o.name || o.id;
								select.appendChild(opt);
							});
							// set default to first
							select.value = outs[0].id;
							midiOut = midiAccess.outputs.get(select.value);
							midiEnabled = !!midiOut;
							updateMidiStatusText(midiOut ? `MIDI: ${midiOut.name || midiOut.id}` : 'MIDI: none');
							console.log('MIDI outputs populated:', outs.map(o=>o.name||o.id));
							// change handler
							select.addEventListener('change', (ev) => {
								const id = select.value;
								midiOut = midiAccess.outputs.get(id) || null;
								midiEnabled = !!midiOut;
								updateMidiStatusText(midiOut ? `MIDI: ${midiOut.name || midiOut.id}` : 'MIDI: none');
							});
						}
					} else {
						// no select found, fallback to first output
						if (outs.length) {
							midiOut = outs[0];
							midiEnabled = true;
							updateMidiStatusText(`MIDI: ${midiOut.name || 'output'}`);
							console.log('MIDI output selected:', midiOut.name || midiOut.id);
						} else {
							updateMidiStatusText('MIDI: no outputs');
							console.warn('No MIDI outputs found');
						}
					}
				} catch(err){
					console.warn('MIDI not available:', err);
					updateMidiStatusText('MIDI: unavailable');
				}
				updateMidiLastText();
			}

			function sendMidiCC(cc, value){
				if (!midiEnabled || !midiOut) return;
				// ensure 0..127
				const v = Math.max(0, Math.min(127, Math.round(value)));
				try{
					// send as Control Change on channel 0 (0xB0)
					midiOut.send([0xB0 | 0x00, cc & 0x7F, v & 0x7F]);
				}catch(e){
					console.warn('MIDI send failed', e);
				}
			}
		// lastSeen timestamps for each forced hand index (ms). Used to reset SVG after timeout.
		let lastSeen = [0,0,0,0];
		const resetTimeoutMs = 800; // ms to wait before resetting SVG to neutral when absent

		// p5 instance (instance mode)
		new p5((sketch) => {
			sketch.setup = function() {
				const container = document.getElementById('sketch-container');
				const cnv = sketch.createCanvas(window.innerWidth, window.innerHeight);
				cnv.parent(container);
				console.log('p5 setup chiamato');
			};

			sketch.windowResized = function(){
				sketch.resizeCanvas(window.innerWidth, window.innerHeight);
			};

					sketch.draw = function(){
					// keep background white
					sketch.background(255);
					// draw numeric distance overlay (top-left)
					sketch.push();
					sketch.noStroke();
					sketch.fill(0, 160);
					sketch.rect(10, 10, 240, 34 + (lastDistances && lastDistances.length > 2 ? 12 : 0), 6);
					sketch.fill(255);
					sketch.textSize(14);
					sketch.textAlign(sketch.LEFT, sketch.CENTER);
					// Show per-hand distances (H0, H1...)
					let textLine = '';
					if (lastDistances && lastDistances.length) {
						const parts = lastDistances.map((v,i) => (typeof v === 'number' && v >= distanceThreshold) ? `H${i}:${v.toFixed(3)}` : `H${i}:—`);
						textLine = parts.join(' ');
					} else {
						textLine = handScale ? `D:${handScale.toFixed(3)}` : 'D:—';
					}
					sketch.text(textLine, 18, 27);
					sketch.pop();
			};
		});

		// Setup debug UI controls (toggle + resizer)
			(function setupDebugControls(){
				const wrap = document.getElementById('debugWrap');
				const handle = document.getElementById('resizeHandle');
				if (!wrap || !handle) return;

			// Resizer
			let isResizing = false;
			let startX = 0, startY = 0, startW = 0, startH = 0;
			const minW = 140, minH = 100;

			handle.addEventListener('pointerdown', (ev) => {
				ev.preventDefault();
				isResizing = true;
				startX = ev.clientX;
				startY = ev.clientY;
				startW = wrap.offsetWidth;
				startH = wrap.offsetHeight;
				handle.setPointerCapture && handle.setPointerCapture(ev.pointerId);
			});

			window.addEventListener('pointermove', (ev) => {
				if (!isResizing) return;
				const dx = ev.clientX - startX;
				const dy = ev.clientY - startY;
				let nw = Math.max(minW, startW + dx);
				let nh = Math.max(minH, startH + dy);
				wrap.style.width = nw + 'px';
				wrap.style.height = nh + 'px';
			});

			window.addEventListener('pointerup', (ev) => {
				if (!isResizing) return;
				isResizing = false;
				handle.releasePointerCapture && handle.releasePointerCapture(ev.pointerId);
			});

			// double-click reset size
			handle.addEventListener('dblclick', () => {
				wrap.style.width = '260px';
				wrap.style.height = '195px';
			});
		})();

		// Initialize Handsfree when available (the local loader injects the real build)
		function initHandsfreeWhenReady(){
			if (window.Handsfree){
				console.log('caricato handsfreejs (libreria disponibile)');
				try{
					const debugWrapEl = document.getElementById('debugWrap');
					// Initialize Handsfree with a small debug wrapper (bottom-left)
					const handsfree = new Handsfree({
						hands: true,
						showDebug: true,
						setup: {
							wrap: { $el: debugWrapEl },
							video: { $el: null, width: 320, height: 240 },
							canvas: { hands: { $el: null, width: 320, height: 240 } }
						}
					});
					// Expose instance for UI controls
					window.handsfreeInstance = handsfree;

					// Plugin that runs every frame and updates `handScale` with an
					// approximate distance/scale measure. Also logs the distance.
					handsfree.use('distanceBg', function(data){
						const hands = data.hands;
						const distances = [];
						const positions = [[0.5, 0.5], [0.5, 0.5]]; // reset positions to center
						const confidences = []; // per-hand confidence mapped to forced indices
						let anyVisible = false;

						// Build a mapping of confidences if available in hands.multiHandedness
						// multiHandedness is aligned with multiHandLandmarks; we need to map it
						// to forced indices (0=Right,1=Left for the first two hands)
						if (hands && Array.isArray(hands.multiHandedness)) {
							for (let n = 0; n < hands.multiHandedness.length; n++) {
								const item = hands.multiHandedness[n];
								if (!item) continue;
								const label = item.label || (item.className || '').toString();
								const score = (typeof item.score === 'number') ? item.score : (typeof item.confidence === 'number' ? item.confidence : null);
								// map to forced index
								let idx = null;
								if (n < 2) idx = (label === 'Right') ? 0 : 1; else idx = (label === 'Right') ? 2 : 3;
								if (idx !== null && score !== null) confidences[idx] = score;
							}
						}

						if (hands && hands.landmarks) {
							for (let h = 0; h < hands.landmarks.length; h++) {
								const lm = hands.landmarks[h];
								const visible = Array.isArray(hands.landmarksVisible) ? hands.landmarksVisible[h] : (h === 0);
								// Only proceed if visible AND confidence (if available) >= threshold
								const conf = (typeof confidences[h] === 'number') ? confidences[h] : null;
								const confOk = conf === null ? true : (conf >= detectionThreshold);
								if (lm && lm.length && visible && confOk) {
									anyVisible = true;
									let metric = 0;
									if (lm[0] && lm[9]) {
										const dx = lm[0].x - lm[9].x;
										const dy = lm[0].y - lm[9].y;
										metric = Math.sqrt(dx*dx + dy*dy);
									} else {
										// fallback: span of detected landmarks
										let xs = [], ys = [];
										for (let i=0;i<lm.length;i++){ if (lm[i]){ xs.push(lm[i].x); ys.push(lm[i].y); } }
										if (xs.length){
											const minx=Math.min(...xs), maxx=Math.max(...xs);
											const miny=Math.min(...ys), maxy=Math.max(...ys);
											metric = Math.sqrt((maxx-minx)*(maxx-minx) + (maxy-miny)*(maxy-miny));
										}
									}
									// Only accept the metric if it exceeds the distanceThreshold
									if (typeof metric === 'number' && metric >= distanceThreshold) {
										distances[h] = metric;
										// only log when hand is visible and metric meets threshold
										console.log(`distanza approssimata mano [${h}] dalla webcam:`, metric);
										// extract hand center position
										let cx = 0, cy = 0, cnt = 0;
										for (let i = 0; i < lm.length; i++) {
											if (lm[i]) { cx += lm[i].x; cy += lm[i].y; cnt++; }
										}
										if (cnt > 0) {
											positions[h] = [cx / cnt, cy / cnt];
										}
									// Calculate hand rotation from wrist (0) to middle finger (9)
									// Vertical = 0 degrees, clockwise positive, counter-clockwise negative
									if (lm[0] && lm[9]) {
										const dx = lm[9].x - lm[0].x;
										const dy = lm[9].y - lm[0].y;
										// atan2 gives angle in radians (-π to π)
										let angle = Math.atan2(dy, dx) * 180 / Math.PI;
										// Rotate so that vertical (pointing up) = 0°
										// atan2 gives 90° for pointing up, so subtract 90°
										angle = angle - 90 + 180; // add 180° offset
										// Normalize to -180..180
										while (angle > 180) angle -= 360;
										while (angle < -180) angle += 360;
										handRotations[h] = angle;
									}
									// Calculate pinch: distance between thumb tip (4) and index tip (8)
									if (lm[4] && lm[8]) {
										const dx = lm[4].x - lm[8].x;
										const dy = lm[4].y - lm[8].y;
										const pinchDist = Math.sqrt(dx*dx + dy*dy);
										pinchActive[h] = pinchDist < pinchThreshold;
										console.log(`pinch mano [${h}]:`, pinchActive[h], 'dist:', pinchDist);
									} else {
										pinchActive[h] = false;
									}
									} else {
										// treat as absent/ignored when too small
										distances[h] = undefined;
									}
								} else {
									// if visible but below confidence threshold, treat as absent
									distances[h] = undefined;
								}
								// store confidence for UI
								confidences[h] = (conf !== null) ? conf : confidences[h];
							}
						}

						// update hand positions
						handPositions = positions;

						if (!anyVisible) {
							lastDistances = [];
							handScale = handScale * 0.95;
							return;
						}

						lastDistances = distances;

						const visibleMetrics = distances.filter(d => typeof d === 'number' && d >= distanceThreshold);
						if (visibleMetrics.length) handScale = Math.max(...visibleMetrics);
					});

					handsfree.enablePlugins('browser');
					// Ensure debugger is visible (sometimes required depending on config)
					handsfree.showDebugger && handsfree.showDebugger();

					// Update the debug distance display from the plugin (if present)
					handsfree.use('distanceUi', function(){
						const dEl = document.getElementById('distanceDisplay');
						if (!dEl) return;
						// If there are no detected hands, don't send/update values
						if (!lastDistances || !lastDistances.length) {
							dEl.textContent = '—';
							return;
						}
						// Build parts only for detected (defined) hands that also meet distanceThreshold
						const parts = [];
						for (let i = 0; i < lastDistances.length; i++) {
							const v = lastDistances[i];
							if (typeof v === 'number' && v >= distanceThreshold) parts.push(`H${i}:${v.toFixed(3)}`);
						}
						// If none defined, show placeholder
						dEl.textContent = parts.length ? parts.join(' ') : '—';
					});

						// Color the SVG hands according to left/right distances each frame
						handsfree.use('distanceHandsUi', function(){
							// mapping: index 0 => Right, index 1 => Left (per HandsModel.forceHandedness)
							const rightDist = (lastDistances && typeof lastDistances[0] === 'number') ? lastDistances[0] : null;
							const leftDist = (lastDistances && typeof lastDistances[1] === 'number') ? lastDistances[1] : null;
							function mapColor(d){
								const minS = 0.02, maxS = 0.45;
								let t = (d - minS) / (maxS - minS);
								t = Math.max(0, Math.min(1, t));
								const r = Math.round(255 * t);
								const g = Math.round(100 * (1 - t));
								const b = Math.round(255 * (1 - t));
								return `rgb(${r},${g},${b})`;
							}

							const rightEl = document.getElementById('handRight');
							const leftEl = document.getElementById('handLeft');
							const now = Date.now();
							// If numeric distances are present, update color and lastSeen
							// Update SVG colors and send MIDI if enabled. Map distances to 0..127
							const mapToCC = (d, minD=distanceThreshold, maxD=0.45) => {
								let t = (d - minD) / (maxD - minD);
								t = Math.max(0, Math.min(1, t));
								return Math.round(t * 127);
							};

							// helper to map 0..1 position to 0..127 MIDI (inverted: 1 -> 0, 0 -> 127)
							const mapPosToCC = (pos) => Math.round((1 - pos) * 127);

							if (rightEl) {
								if (rightDist !== null && rightDist >= distanceThreshold) {
									rightEl.style.fill = mapColor(rightDist);
									lastSeen[0] = now;
									// MIDI send for right distance (CC40 - index 5)
									const ccVal = mapToCC(rightDist);
									if (midiEnabled && midiOut && ccEnabled[5]) {
										if (ccVal !== lastMidiValue[5] && (now - lastMidiSentAt[5] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_DIST, ccVal);
											lastMidiValue[5] = ccVal;
											lastMidiSentAt[5] = now;
											updateMidiLastText();
										}
									}
									// MIDI send for right position (CC35, CC36 = x, y)
									const [posX, posY] = handPositions[0];
									const posXCC = mapPosToCC(posX);
									const posYCC = mapPosToCC(posY);
									if (midiEnabled && midiOut) {
										if (ccEnabled[3] && posXCC !== lastMidiValue[3] && (now - lastMidiSentAt[3] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_X, posXCC);
											lastMidiValue[3] = posXCC;
											lastMidiSentAt[3] = now;
											updateMidiLastText();
										}
										if (ccEnabled[4] && posYCC !== lastMidiValue[4] && (now - lastMidiSentAt[4] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_Y, posYCC);
											lastMidiValue[4] = posYCC;
											lastMidiSentAt[4] = now;
											updateMidiLastText();
										}
									}
									// MIDI send for right rotation (CC41 - index 7)
									// Map -90..+90 degrees to 0..127 (inverted): -90° (left)=127, 0°(vertical)=63, +90°(right)=0
									const rotDeg = handRotations[0];
									const rotCC = Math.round(63 - (rotDeg / 90) * 64); // -90->127, 0->63, 90->0
									const rotCCClamped = Math.max(0, Math.min(127, rotCC));
									if (midiEnabled && midiOut && ccEnabled[7]) {
									if (rotCCClamped !== lastMidiValue[7] && (now - lastMidiSentAt[7] > midiThrottleMs)) {
										sendMidiCC(CC_RIGHT_ROT, rotCCClamped);
										lastMidiValue[7] = rotCCClamped;
										lastMidiSentAt[7] = now;
										updateMidiLastText();
									}
								}
								// MIDI send for right hand pinch-based CCs (CC43-46, indices 8-11)
								if (midiEnabled && midiOut) {
									// CC43: Pinch state (0 = not pinching, 127 = pinching)
									const pinchCC = pinchActive[0] ? 127 : 0;
									if (ccEnabled[8] && pinchCC !== lastMidiValue[8] && (now - lastMidiSentAt[8] > midiThrottleMs)) {
										sendMidiCC(CC_RIGHT_PINCH, pinchCC);
										lastMidiValue[8] = pinchCC;
										lastMidiSentAt[8] = now;
									}
									// Only send pinch movement if pinch is active
									if (pinchActive[0]) {
										// CC44: Pinch X
										if (ccEnabled[9] && posXCC !== lastMidiValue[9] && (now - lastMidiSentAt[9] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_PINCH_X, posXCC);
											lastMidiValue[9] = posXCC;
											lastMidiSentAt[9] = now;
										}
										// CC45: Pinch Y
										if (ccEnabled[10] && posYCC !== lastMidiValue[10] && (now - lastMidiSentAt[10] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_PINCH_Y, posYCC);
											lastMidiValue[10] = posYCC;
											lastMidiSentAt[10] = now;
										}
										// CC46: Pinch Rotation
										if (ccEnabled[11] && rotCCClamped !== lastMidiValue[11] && (now - lastMidiSentAt[11] > midiThrottleMs)) {
											sendMidiCC(CC_RIGHT_PINCH_ROT, rotCCClamped);
											lastMidiValue[11] = rotCCClamped;
											lastMidiSentAt[11] = now;
										}
									}
								}
							// move SVG hand to position (invert X because preview is mirrored) and rotate
								const offsetX = (-(posX - 0.5)) * window.innerWidth * 0.4;
								const offsetY = (posY - 0.5) * window.innerHeight * 0.4;
								rightEl.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${-rotDeg}deg)`;
								
						// Update right hand labels and move them with the hand
						const rightLabels = document.getElementById('rightHandLabels');
						if (rightLabels) {
							// Calculate pinch CC value
							const pinchCC = pinchActive[0] ? 127 : 0;
							const pinchCCX = pinchActive[0] ? posXCC : 0;
							const pinchCCY = pinchActive[0] ? posYCC : 0;
							const pinchCCRot = pinchActive[0] ? rotCCClamped : 0;
							// Update label text
							document.getElementById('rightLabel_x').textContent = `X (CC35): ${posXCC}`;
							document.getElementById('rightLabel_y').textContent = `Y (CC36): ${posYCC}`;
							document.getElementById('rightLabel_dist').textContent = `Dist (CC37): ${ccVal}`;
							document.getElementById('rightLabel_rot').textContent = `Rot (CC41): ${rotCCClamped}`;
							document.getElementById('rightLabel_pinch').textContent = `Pinch (CC43): ${pinchCC}`;
							document.getElementById('rightLabel_pinch_x').textContent = `PX (CC44): ${pinchCCX}`;
							document.getElementById('rightLabel_pinch_y').textContent = `PY (CC45): ${pinchCCY}`;
							document.getElementById('rightLabel_pinch_rot').textContent = `PR (CC46): ${pinchCCRot}`;
							// Move labels with hand (position top-left relative to hand)
							rightLabels.style.transform = `translate(calc(-50% + ${offsetX}px - 220px), calc(-50% + ${offsetY}px - 150px))`;
							rightLabels.style.opacity = '1';
						}
						} else if (now - (lastSeen[0] || 0) > resetTimeoutMs) {
							// reset to neutral after timeout
							rightEl.style.fill = '#ddd';
							rightEl.style.transform = 'translate(0, 0) rotate(0deg)';
							// Hide labels when hand not detected
							const rightLabels = document.getElementById('rightHandLabels');
							if (rightLabels) {
								rightLabels.style.opacity = '0';
							}
							// Reset pinch circle to gray when hand not detected
							const pinchCircle = document.getElementById('pinchCircle');
							if (pinchCircle) {
								pinchCircle.setAttribute('fill', '#ddd');
							}
								}
							}
							// Update pinch indicator circle for right hand
							const pinchCircle = document.getElementById('pinchCircle');
							if (pinchCircle) {
								if (pinchActive[0]) {
									pinchCircle.setAttribute('fill', '#ff0000'); // red when pinch active
								} else {
									pinchCircle.setAttribute('fill', '#cccccc'); // gray when not active
								}
							}
							if (leftEl) {
								if (leftDist !== null && leftDist >= distanceThreshold) {
									leftEl.style.fill = mapColor(leftDist);
									lastSeen[1] = now;
									// MIDI send for left distance (CC40 - index 2)
									const ccVal = mapToCC(leftDist);
									if (midiEnabled && midiOut && ccEnabled[2]) {
										if (ccVal !== lastMidiValue[2] && (now - lastMidiSentAt[2] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_DIST, ccVal);
											lastMidiValue[2] = ccVal;
											lastMidiSentAt[2] = now;
											updateMidiLastText();
										}
									}
									// MIDI send for left position (CC35, CC36 = x, y)
									const [posX, posY] = handPositions[1];
									const posXCC = mapPosToCC(posX);
									const posYCC = mapPosToCC(posY);
									if (midiEnabled && midiOut) {
										if (ccEnabled[0] && posXCC !== lastMidiValue[0] && (now - lastMidiSentAt[0] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_X, posXCC);
											lastMidiValue[0] = posXCC;
											lastMidiSentAt[0] = now;
											updateMidiLastText();
										}
										if (ccEnabled[1] && posYCC !== lastMidiValue[1] && (now - lastMidiSentAt[1] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_Y, posYCC);
											lastMidiValue[1] = posYCC;
											lastMidiSentAt[1] = now;
											updateMidiLastText();
										}
									}
									// MIDI send for left rotation (CC42 - index 6)
									// Map -90..+90 degrees to 0..127 (inverted): -90° (left)=127, 0°(vertical)=63, +90°(right)=0
									const rotDeg = handRotations[1];
									const rotCC = Math.round(63 - (rotDeg / 90) * 64); // -90->127, 0->63, 90->0
									const rotCCClamped = Math.max(0, Math.min(127, rotCC));
								if (midiEnabled && midiOut && ccEnabled[6]) {
									if (rotCCClamped !== lastMidiValue[6] && (now - lastMidiSentAt[6] > midiThrottleMs)) {
										sendMidiCC(CC_LEFT_ROT, rotCCClamped);
										lastMidiValue[6] = rotCCClamped;
										lastMidiSentAt[6] = now;
										updateMidiLastText();
									}
								}
								// MIDI send for left hand pinch-based CCs (CC47-50, indices 12-15)
								if (midiEnabled && midiOut) {
									// CC47: Pinch state (0 = not pinching, 127 = pinching)
									const pinchCC = pinchActive[1] ? 127 : 0;
									if (ccEnabled[12] && pinchCC !== lastMidiValue[12] && (now - lastMidiSentAt[12] > midiThrottleMs)) {
										sendMidiCC(CC_LEFT_PINCH, pinchCC);
										lastMidiValue[12] = pinchCC;
										lastMidiSentAt[12] = now;
									}
									// Only send pinch movement if pinch is active
									if (pinchActive[1]) {
										// CC48: Pinch X
										if (ccEnabled[13] && posXCC !== lastMidiValue[13] && (now - lastMidiSentAt[13] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_PINCH_X, posXCC);
											lastMidiValue[13] = posXCC;
											lastMidiSentAt[13] = now;
										}
										// CC49: Pinch Y
										if (ccEnabled[14] && posYCC !== lastMidiValue[14] && (now - lastMidiSentAt[14] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_PINCH_Y, posYCC);
											lastMidiValue[14] = posYCC;
											lastMidiSentAt[14] = now;
										}
										// CC50: Pinch Rotation
										if (ccEnabled[15] && rotCCClamped !== lastMidiValue[15] && (now - lastMidiSentAt[15] > midiThrottleMs)) {
											sendMidiCC(CC_LEFT_PINCH_ROT, rotCCClamped);
											lastMidiValue[15] = rotCCClamped;
											lastMidiSentAt[15] = now;
										}
									}
								}
							// move SVG hand to position (invert X because preview is mirrored) and rotate
								const offsetX = (-(posX - 0.5)) * window.innerWidth * 0.4;
								const offsetY = (posY - 0.5) * window.innerHeight * 0.4;
								leftEl.style.transform = `translate(${offsetX}px, ${offsetY}px) rotate(${-rotDeg}deg)`;
								
							// Update left hand labels and move them with the hand
						const leftLabels = document.getElementById('leftHandLabels');
						if (leftLabels) {
							// Calculate pinch CC value
							const pinchCC = pinchActive[1] ? 127 : 0;
							const pinchCCX = pinchActive[1] ? posXCC : 0;
							const pinchCCY = pinchActive[1] ? posYCC : 0;
							const pinchCCRot = pinchActive[1] ? rotCCClamped : 0;
							// Update label text
							document.getElementById('leftLabel_x').textContent = `X (CC38): ${posXCC}`;
							document.getElementById('leftLabel_y').textContent = `Y (CC39): ${posYCC}`;
							document.getElementById('leftLabel_dist').textContent = `Dist (CC40): ${ccVal}`;
							document.getElementById('leftLabel_rot').textContent = `Rot (CC42): ${rotCCClamped}`;
							document.getElementById('leftLabel_pinch').textContent = `Pinch (CC47): ${pinchCC}`;
							document.getElementById('leftLabel_pinch_x').textContent = `PX (CC48): ${pinchCCX}`;
							document.getElementById('leftLabel_pinch_y').textContent = `PY (CC49): ${pinchCCY}`;
							document.getElementById('leftLabel_pinch_rot').textContent = `PR (CC50): ${pinchCCRot}`;
							// Move labels with hand (position top-left relative to hand)
							leftLabels.style.transform = `translate(calc(-50% + ${offsetX}px + 70px), calc(-50% + ${offsetY}px - 150px))`;
							leftLabels.style.opacity = '1';
						}
						} else if (now - (lastSeen[1] || 0) > resetTimeoutMs) {
							leftEl.style.fill = '#ddd';
							leftEl.style.transform = 'translate(0, 0) rotate(0deg)';
							// Hide labels when hand not detected
							const leftLabels = document.getElementById('leftHandLabels');
							if (leftLabels) {
								leftLabels.style.opacity = '0';
							}
							// Reset pinch circle to gray when hand not detected
							const pinchCircleLeft = document.getElementById('pinchCircleLeft');
							if (pinchCircleLeft) {
								pinchCircleLeft.setAttribute('fill', '#ddd');
							}
						}
							// Update pinch indicator circle for left hand
							const pinchCircleLeft = document.getElementById('pinchCircleLeft');
							if (pinchCircleLeft) {
								if (pinchActive[1]) {
									pinchCircleLeft.setAttribute('fill', '#ff0000'); // red when pinch active
								} else {
									pinchCircleLeft.setAttribute('fill', '#cccccc'); // gray when not active
								}
							}
							}
						});
					handsfree.start(() => {
						console.log('handsfree avviato (start callback)');
					});

					// Hook up MIDI enable button (if present)
					const midiBtn = document.getElementById('midiEnable');
					if (midiBtn) {
						midiBtn.addEventListener('click', async () => {
							await enableMidi();
							// disable the button to avoid repeated requests
							midiBtn.disabled = true;
						});
					}

				// Hook up threshold slider to update display
				const thresholdSlider = document.getElementById('thresholdSlider');
				const thresholdValue = document.getElementById('thresholdValue');
				if (thresholdSlider && thresholdValue) {
					thresholdSlider.addEventListener('input', (e) => {
						distanceThreshold = parseFloat(e.target.value);
						thresholdValue.textContent = distanceThreshold.toFixed(2);
					});
				}

				// Hook up CC toggle buttons
				const ccToggleButtons = document.querySelectorAll('.cc-toggle');
				ccToggleButtons.forEach(btn => {
					btn.addEventListener('click', () => {
						const ccIndex = parseInt(btn.getAttribute('data-cc-index'));
						toggleCCEnabled(ccIndex);
					});
				});
			} catch (err){
					console.error('Errore inizializzazione Handsfree:', err);
				}
			} else {
				setTimeout(initHandsfreeWhenReady, 200);
			}
		}

		initHandsfreeWhenReady();
	</script>
</body>
</html>
